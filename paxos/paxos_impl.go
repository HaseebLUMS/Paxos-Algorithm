/*
	Assignment by: 20100192 Muhammad Haseeb, 20100212 Ammar Tahir
	This is an implementation of keyValue store where consesnus is reached using Paxos consensus algorithm. Following are the steps of implementation:
	1 - Create paxosNode listener and connect with all the other paxosNodes
	2 - To propose a value for key, get a proposal number and send a Prepare message to all the other nodes. Wait for response of majority of nodes.
	3 - Proposal number is generated by 5000*ID and then incremented before proposing everytime.
	4 - After receiving majority responses, set value to the value against highest proposal number from responses (if any). Send this value as Accept message.
	5 - After receiving majority responses, send the commit message and then wait for all nodes to commit.
	6 - When a paxos node recieves prepare message, it sends back OK or reject message after checking if the proposal number is higher than the highest proposal number it has seen.
	7 - When accept message is received, we again check if proposal number is equal to the highest proposal number, based on this we send accept and reject. We also save state against this key athis step.
	8 - On receiving commit, save the key value pair to keyValue Store and delete its temporary state.
	9 - When an accept message is rejected by majority, we get a new proposal number and run the propose function again. This repeats until a value has been committed on every node.
	10 - To handle failure case, when a node is created with replace flag set true, we update its hostport in all other nodes through recvReplaceServer api and its key value store is updated through recvReplaceCatchup.

*/
package paxos

import (
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"net/http"
	"net/rpc"
	"paxosapp/rpc/paxosrpc"
	"time"
)

//PROPOSE_TIMEOUT is used for timeout still unknow
var PROPOSE_TIMEOUT = 15 * time.Second

type consState struct { //type used for consensusState amp
	highestProposalNumber  int
	value                  interface{}
	acceptedProposalNumber int
	helperUniqueNumber     int
}
type cns struct { //type used for consensusState Write Channel
	key   string
	value consState
}

type kvs struct { //type used for key-value-store channels
	key    string
	value  interface{}
	exists bool
}
type paxosNode struct {
	ID                 int
	rpcConnMap         map[int](*rpc.Client)
	rcmReadChan        chan bool
	rcmResponseChan    chan map[int](*rpc.Client)
	helperUniqueNumber int

	keyValueStore   map[string]interface{}
	kvsReadChan     chan string
	kvsWriteChan    chan kvs
	kvsResponseChan chan kvs

	consensusState       map[string]consState
	cnsStateResponseChan chan consState
	cnsStateReadChan     chan string
	cnsStateWriteChan    chan cns

	semaphore            chan int
	proposalNumSemaphore chan int
}

// NewPaxosNode creates a new PaxosNode. This function should return only when
// all nodes have joined the ring, and should return a non-nil error if this node
// could not be started in spite of dialing any other nodes numRetries times.
//
// Params:
// myHostPort: the hostport string of this new node. We use tcp in this project.
//			   	Note: Please listen to this port rather than hostMap[srvId]
// hostMap: a map from all node IDs to their hostports.
//				Note: Please connect to hostMap[srvId] rather than myHostPort
//				when this node try to make rpc call to itself.
// numNodes: the number of nodes in the ring
// numRetries: if we can't connect with some nodes in hostMap after numRetries attempts, an error should be returned
// replace: a flag which indicates whether this node is a replacement for a node which failed.

func NewPaxosNode(myHostPort string, hostMap map[int]string, numNodes, srvId, numRetries int, replace bool) (PaxosNode, error) {
	node := new(paxosNode)
	node.ID = srvId
	node.cnsStateWriteChan = make(chan cns)
	node.cnsStateReadChan = make(chan string)
	node.cnsStateResponseChan = make(chan consState)
	node.consensusState = make(map[string]consState)
	node.keyValueStore = make(map[string]interface{})
	node.kvsReadChan = make(chan string)
	node.kvsWriteChan = make(chan kvs)
	node.kvsResponseChan = make(chan kvs)
	node.helperUniqueNumber = node.ID * 100
	node.rpcConnMap = make(map[int](*rpc.Client))
	node.rcmReadChan = make(chan bool)
	node.rcmResponseChan = make(chan map[int](*rpc.Client))
	node.semaphore = make(chan int, 1)
	node.proposalNumSemaphore = make(chan int, 1)
	node.semaphore <- 1
	node.proposalNumSemaphore <- 1
	//Running a server
	ln, err := net.Listen("tcp", myHostPort)
	if err != nil {
		return nil, err
	}
	rpcServer := rpc.NewServer()
	rpcServer.Register(paxosrpc.Wrap(node))
	http.DefaultServeMux = http.NewServeMux()
	rpcServer.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
	go http.Serve(ln, nil)
	//Opening connections to all peers
	doneCatchup := make(chan *rpc.Call, len(hostMap))
	for id, p := range hostMap {
		if replace == true && id == node.ID {
			continue
		}
		if replace == true {
			cli, err := rpc.DialHTTP("tcp", p)
			if err != nil {
				fmt.Println(err.Error())
			}
			node.rpcConnMap[id] = cli
			inputArgs := paxosrpc.ReplaceServerArgs{SrvID: node.ID, Hostport: myHostPort}
			output := paxosrpc.ReplaceServerReply{}
			doneP := make(chan *rpc.Call, len(hostMap))
			cli.Go("PaxosNode.RecvReplaceServer", &inputArgs, &output, doneP)
			inputArgsCatchup := paxosrpc.ReplaceCatchupArgs{}
			outputCatchup := paxosrpc.ReplaceCatchupReply{}
			cli.Go("PaxosNode.RecvReplaceCatchup", &inputArgsCatchup, &outputCatchup, doneCatchup)
		} else {
			for turn := 0; turn < numRetries; turn++ {
				cli, err := rpc.DialHTTP("tcp", p)
				if err == nil {
					node.rpcConnMap[id] = cli
					break
				} else if err != nil && turn == numRetries-1 {
					// return error after numRetries for any connection
					return nil, errors.New("Couldn't make connection, bruh " + err.Error())
				}
				time.Sleep(1 * time.Second)
			}
		}
	}
	if replace == true {
		ketchUp := <-doneCatchup
		data := ketchUp.Reply.(*paxosrpc.ReplaceCatchupReply)
		var res map[string]uint32
		err = json.Unmarshal(data.Data, &res)
		for k, v := range res {
			node.keyValueStore[k] = v
		}
	}
	//Spinning all go rounties for handling race conditions
	go func() { //consensusState Map protector
		for {
			select {
			case v := <-node.cnsStateReadChan:
				res, exists := node.consensusState[v]
				if !exists {
					res = consState{highestProposalNumber: -100}
				}
				node.cnsStateResponseChan <- res
			case v := <-node.cnsStateWriteChan:
				node.consensusState[v.key] = v.value
			}
		}
	}()

	go func() { //key-value-store map protector
		for {
			select {
			case v := <-node.kvsReadChan:
				value, exists := node.keyValueStore[v]
				node.kvsResponseChan <- kvs{key: v, value: value, exists: exists}
			case v := <-node.kvsWriteChan:
				node.keyValueStore[v.key] = v.value
			}
		}
	}()

	go func() { //rpcConnMap protector (replacement node might need writes)
		for {
			select {
			case <-node.rcmReadChan:
				mapCopy := make(map[int](*rpc.Client))
				for k, v := range node.rpcConnMap {
					mapCopy[k] = v
				}
				node.rcmResponseChan <- mapCopy
			}
		}
	}()
	return node, nil
}

// Desc:
// GetNextProposalNumber generates a proposal number which will be passed to
// Propose. Proposal numbers should not repeat for a key, and for a particular
// <node, key> pair, they should be strictly increasing.
//
// Params:
// args: the key to propose
// reply: the next proposal number for the given key

func (pn *paxosNode) GetNextProposalNumber(args *paxosrpc.ProposalNumberArgs, reply *paxosrpc.ProposalNumberReply) error {
	// helperUniqueNumber is initiated at 5000*ID, in this function we just increment this variable and pass it as next proposal number
	key := args.Key
	<-pn.proposalNumSemaphore
	pn.cnsStateWriteChan <- cns{key: key, value: consState{highestProposalNumber: -1, value: nil, acceptedProposalNumber: -1}}
	reply.N = pn.helperUniqueNumber
	pn.helperUniqueNumber++
	pn.proposalNumSemaphore <- 1
	return nil
}

// Desc:
// Propose initializes proposing a value for a key, and replies with the
// value that was committed for that key. Propose should not return until
// a value has been committed, or PROPOSE_TIMEOUT seconds have passed.
//
// Params:
// args: the key, value pair to propose together with the proposal number returned by GetNextProposalNumber
// reply: value that was actually committed for the given key
func (pn *paxosNode) Propose(args *paxosrpc.ProposeArgs, reply *paxosrpc.ProposeReply) error {
	proposalNumber := args.N
	toProposeKey := args.Key
	toProposeValue := args.V
	<-pn.semaphore
	for {
		pn.rcmReadChan <- true
		rpcConnMap := <-pn.rcmResponseChan

		//Broadcasting Prepare message (P = Prepare)
		doneP := make(chan *rpc.Call, len(rpcConnMap))
		OASindexP := 0 //outoutArgsSlice index
		for _, nodeConn := range rpcConnMap {
			tmp := paxosrpc.PrepareReply{}
			inputArgs := paxosrpc.PrepareArgs{Key: toProposeKey, N: proposalNumber, RequesterId: pn.ID}
			nodeConn.Go("PaxosNode.RecvPrepare", &inputArgs, &tmp, doneP)
			OASindexP++
		}
		// Waiting for majority to reply
		for {
			if len(doneP) >= 1+len(rpcConnMap)/2 {
				break
			}
		}
		highestProposersNumber := -1
		var highestProposersValue interface{}
		highestProposersValue = nil
		// Checking in responses for highest Accepted value if any
		for i := 0; i < len(doneP); i++ {
			cv := <-doneP
			replyP := cv.Reply.(*paxosrpc.PrepareReply)
			if replyP.V_a != nil {
				if replyP.N_a > highestProposersNumber {
					highestProposersNumber = replyP.N_a
					highestProposersValue = replyP.V_a
				}
			}
		}
		if highestProposersValue != nil {
			toProposeValue = highestProposersValue
		}

		//Broadcasting Accept message (A = Accept)
		doneA := make(chan *rpc.Call, len(rpcConnMap))
		OASindexA := 0
		for _, nodeConn := range rpcConnMap {
			tmp := paxosrpc.AcceptReply{}
			inputArgs := paxosrpc.AcceptArgs{Key: toProposeKey, N: proposalNumber, V: toProposeValue, RequesterId: pn.ID}
			nodeConn.Go("PaxosNode.RecvAccept", &inputArgs, &tmp, doneA)
			OASindexA++
		}
		// Waiting for majority to reply
		for {
			if len(doneA) >= 1+len(rpcConnMap)/2 {
				break
			}
		}

		/*
			If any proposal is rejected by majority, reiterate
			... continued to next part
		*/
		majCount := 1 + len(rpcConnMap)/2
		for i := 0; i < cap(doneA); i++ {
			cv := <-doneA
			replyA := cv.Reply.(*paxosrpc.AcceptReply)
			if replyA.Status == paxosrpc.OK {
				majCount--
			}
			if majCount == 0 {
				break
			}
		}
		if majCount > 0 {
			doneP := make(chan *rpc.Call, 1)
			tmp := paxosrpc.ProposalNumberReply{}
			inputArgs := paxosrpc.ProposalNumberArgs{Key: toProposeKey}
			rpcConnMap[pn.ID].Go("PaxosNode.GetNextProposalNumber", &inputArgs, &tmp, doneP)
			cv := <-doneP
			replyP := cv.Reply.(*paxosrpc.ProposalNumberReply)
			proposalNumber = replyP.N
			continue
		}
		//Broadcasting commit message
		doneC := make(chan *rpc.Call, len(rpcConnMap))
		OASindexC := 0
		for _, nodeConn := range rpcConnMap {
			tmp := paxosrpc.CommitReply{}
			inputArgs := paxosrpc.CommitArgs{Key: toProposeKey, V: toProposeValue, RequesterId: pn.ID}
			nodeConn.Go("PaxosNode.RecvCommit", &inputArgs, &tmp, doneC)
			OASindexC++
		}
		// Waiting for all responses
		for {
			if len(doneC) == len(rpcConnMap) {
				break
			}
		}
		reply.V = toProposeValue
		break
	}
	pn.semaphore <- 1
	return nil
}

// Desc:
// GetValue looks up the value for a key, and replies with the value or with
// the Status KeyNotFound.
//Running testMultipleSequentialProposers:

// Params:
// args: the key to check
// reply: the value and status for this lookup of the given key
func (pn *paxosNode) GetValue(args *paxosrpc.GetValueArgs, reply *paxosrpc.GetValueReply) error {
	// Checks for value in keyvalue DB, if key is present pass back the value otherwise KeyNotFound sent, channels used for race condition elimination
	pn.kvsReadChan <- args.Key
	state := <-pn.kvsResponseChan
	value := state.value
	exists := state.exists
	if !exists {
		reply.Status = paxosrpc.KeyNotFound
	} else {
		reply.Status = paxosrpc.KeyFound
		reply.V = value
	}
	return nil
}

// Desc:
// Receive a Prepare message from another Paxos Node. The message contains
// the key whose value is being proposed by the node sending the prepare
// message. This function should respond with Status OK if the prepare is
// accepted and Reject otherwise.
//
// Params:
// args: the Prepare Message, you must include RequesterId when you call this API
// reply: the Prepare Reply Message
func (pn *paxosNode) RecvPrepare(args *paxosrpc.PrepareArgs, reply *paxosrpc.PrepareReply) error {
	// Checks if proposed proposal is bigger than last highest proposal, send it OK else send Reject.
	// Also return highest accepted proposal number and corresponding value
	proposedKey := args.Key
	proposalNumber := args.N
	pn.cnsStateReadChan <- proposedKey
	state := <-pn.cnsStateResponseChan
	currentHighestPN := state.highestProposalNumber
	reply.N_a = state.acceptedProposalNumber
	reply.V_a = state.value
	if proposalNumber > currentHighestPN {
		reply.Status = paxosrpc.OK
		prevState := state
		pn.cnsStateWriteChan <- cns{key: proposedKey, value: consState{highestProposalNumber: proposalNumber, value: prevState.value, acceptedProposalNumber: prevState.acceptedProposalNumber}}
	} else {
		reply.Status = paxosrpc.Reject
	}
	return nil
}

// Desc:
// Receive an Accept message from another Paxos Node. The message contains
// the key whose value is being proposed by the node sending the accept
// message. This function should respond with Status OK if the prepare is
// accepted and Reject otherwise.
//
// Params:
// args: the Please Accept Message, you must include RequesterId when you call this API
// reply: the Accept Reply Message
func (pn *paxosNode) RecvAccept(args *paxosrpc.AcceptArgs, reply *paxosrpc.AcceptReply) error {
	// record state of key and respond with OK if it is accepted, else respond with reject message
	pn.cnsStateReadChan <- args.Key
	state := <-pn.cnsStateResponseChan

	if args.N >= state.highestProposalNumber {
		pn.cnsStateWriteChan <- cns{key: args.Key, value: consState{highestProposalNumber: args.N, value: args.V, acceptedProposalNumber: args.N}}
	}

	if state.highestProposalNumber > args.N {
		reply.Status = paxosrpc.Reject
	} else {
		reply.Status = paxosrpc.OK
	}
	return nil
}

// Desc:
// Receive a Commit message from another Paxos Node. The message contains
// the key whose value was proposed by the node sending the commit
// message.
//
// Params:
// args: the Commit Message, you must include RequesterId when you call this API
// reply: the Commit Reply Message
func (pn *paxosNode) RecvCommit(args *paxosrpc.CommitArgs, reply *paxosrpc.CommitReply) error {
	// Commit key, value to keyValue Store and clear paxos state of the key
	pn.kvsWriteChan <- kvs{key: args.Key, value: args.V}
	pn.cnsStateReadChan <- args.Key
	prevState := <-pn.cnsStateResponseChan
	pn.cnsStateWriteChan <- cns{key: args.Key, value: consState{highestProposalNumber: prevState.highestProposalNumber, value: nil, acceptedProposalNumber: prevState.acceptedProposalNumber}}
	return nil
}

// Desc:
// Notify another node of a replacement server which has started up. The
// message contains the Server ID of the node being replaced, and the
// hostport of the replacement node
//
// Params:
// args: the id and the hostport of the server being replaced
// reply: no use
func (pn *paxosNode) RecvReplaceServer(args *paxosrpc.ReplaceServerArgs, reply *paxosrpc.ReplaceServerReply) error {
	cli, _ := rpc.DialHTTP("tcp", args.Hostport)
	pn.rpcConnMap[args.SrvID] = cli
	return nil
}

// Desc:
// Request the value that was agreed upon for a particular round. A node
// receiving this message should reply with the data (as an array of bytes)
// needed to make the replacement server aware of the keys and values
// committed so far.
//
// Params:
// args: no use
// reply: a byte array containing necessary data used by replacement server to recover
func (pn *paxosNode) RecvReplaceCatchup(args *paxosrpc.ReplaceCatchupArgs, reply *paxosrpc.ReplaceCatchupReply) error {
	kvs := make(map[string]uint32)
	for k, v := range pn.keyValueStore {
		r, _ := v.(uint32)
		kvs[k] = r
	}
	mapMarshalled, _ := json.Marshal(kvs)
	reply.Data = mapMarshalled
	return nil
}
